---
title: "Julia: оптимизация вычислений во время компиляции"
author: "Сергей А. Романенко"
date: "4/23/2024"
format:
  revealjs:
    theme: [default, julia_ct_opt_slides.scss]
    from: markdown+emoji
    lang: ru-RU
    code-fold: false
    code-line-numbers: false
    code-block-height: 600px
    slide-number: true
    smaller: true
    embed-resources: false
    pdf-separate-fragments: true
execute: 
  echo: true
jupyter: julia-1.10
---

## Система программирования Julia

Сайт: <https://julialang.org/>

Особенности и полезные свойства:

- Язык - с динамической типизацией (как Lisp или Python). Но типы, при
  желании, можно указывать.
- Типы являются полноправными значениями (как числа, например).
- Нет жесткого разделения на время компиляции и время исполнения.
  Немного посчитали - немного покомпилировали.
- Можно генерировать какие-то части программы - и тут же их исполнять.
- Если нужно, можно достигать такой же скорости работы, как и у программ
  <br/>на `C++`.
- Сочетание низменного (:sandal: :waning_crescent_moon:) и возвышенного
  (:high_heel: :high_brightness:)! Вместо использования комбинации из
  Python и C++, всё можно делать оставаясь в рамках языка Julia.

## Julia: что будем использовать?

В примерах программ используются несколько пакетов:

```{julia}
using CompTime, InteractiveUtils, MacroTools
```

- `CompTime` - позволяет записывать генерирующие фунции (`@generated`) в
  более читабельном виде.
- `InteractiveUtils` - позволяет заглядывать в промежуточные результаты
  работы компилятора (с помощью макросов `@code_lowered` и
  `@code_typed`).
- `MacroTools` - позволяет упростить программу, убрав лишние
  `begin ... end` из.

```{julia}
#| output: false
cleanup = MacroTools.flatten ∘ Base.remove_linenums!
```

- Определяем функцию, которая удаляет лишние `begin ... end` и номера
  строк из исходной программы.

## Julia: специализация функций по типам

```{julia}
#| output: false
sq(x) = x * x
```

Вызываем с аргументами разных типов:

```{julia}
(sq(3), sq(3.0), sq("Abc"))
```

В момент вызова под каждую комбинацию типов аргументов создаётся
отдельная версия функции!

```{julia}
@code_typed sq(3)
```

```{julia}
@code_typed sq(3.0)
```

## Модельная задача: $x^n$

В качестве (крошечной) модельной задачи будем использовать возведение в
степень $x^n$.

- Поскольку имеется два параметра ($n$ и $x$), можно проводить
  специализацию программы по отношению к заданному значению одного из
  параметров.
- "Наивный" алгоритм основан на соотношениях $x^0 = 1$ и $x^{n+1} =
  x*x^n$, и имеет время работы $O(n)$.
- Более "продвинутый" алгоритм использует ещё и соотношение $x^{2n} =
  (x*x)^n$ и имеет время работы $O(\log n)$.
- В результате специализации по $n$ из программы исчезают все циклы и
  ветвления.

## План

- Сначала рассмотрим "наивную" реализацию вычисления $x^n$ в виде
  императивной программы, реализующей вычисление как
  $$ 1 * \underbrace{x * \ldots * x}_{\mbox{$n$ - раз}}$$
- Специализировать эту программу - неинтересно, ибо она содержит цикл,
  но не содержит ветвлений. Поэтому - начинаем движение к реализации
  "продвинутого" алгоритма.
- Переписываем программу в функциональном виде (заменяем цикл на
  рекурсию).
- Дорабатываем функциональную программу, чтобы она реализовывала
  "продвинутый" алгоритм. Пробуем проспециализировать её по $n$.
- Переписываем программу в императивном виде. Пробуем
  проспециализировать её по $n$.


## Императивное вычисление $x^n$<br/>за время $O(n)$

```{julia}
#| output: false
function pw_naive_loop(n, x::T) where {T}
    r = one(T)
    for k in 1:n
        r = r * x
    end
    return r
end
```

Проверяем (на строках)

```{julia}
Tuple(pw_naive_loop(n, "Abc") for n in 0:5)
```

Проверяем (на числах)

```{julia}
Tuple(pw_naive_loop(n, 3) for n in 0:5)
```

- Для строк, `*` - конкатенация, а `one(String)` - это `""`.


## Рекурсивное вычисление $x^n$<br/>за время $O(n)$

- Если $n=0$, выдаём `one(T)`.
- Если $n>0$, сводим задачу к более простой, для $n-1$.

```{julia}
#| output: false
function pw_naive_rec(n, x::T) where {T}
    if iszero(n)
        one(T)
    else
        x * pw_naive_rec(n - 1, x)
    end
end
```

Проверяем

```{julia}
Tuple(pw_naive_rec(n, "Abc") for n in 0:5)
```


## Рекурсивное вычисление $x^n$<br/>за время $O(\log n)$

- Для $n>0$, если $n$ - чётное, сводим задачу к случаю $n \div 2$.

```{julia}
#| output: false
function pw_rec(n, x::T) where {T}
    if iszero(n)
        one(T)
    elseif isodd(n)
        x * pw_rec(n - 1, x)
    else
        pw_rec(n ÷ 2, x * x)
    end
end
```

Проверяем:

```{julia}
Tuple(pw_rec(n, "Abc") for n in 0:5)
```

## Обёртывание констант в типы<br/>:fearful::scream::exclamation:

Тип `Val` определён в стандартной библиотеке:

```julia
struct Val{v} end

Val(v) = Val{v}()
```

Тип `Val{v}` населён единственным значением `Val{v}()`, которое
порождается конструктором `Val(v)`.

Хитрость состоит в том, что параметр `v` может быть "обычной"
константой!

```julia
Val(99) ⟹ Val{99}()
typeof(Val(99)) ⟹ Val{99}
Val((1, 2, (3, 4))) ⟹ Val{(1, 2, (3, 4))}()
```
## Извлечение констант из типов

Значение можно "выковырнуть" из типа!

```julia
get_val(::Val{n}) where {n} = n
```

Проверяем:

```julia
get_val(Val(99)) ⟹ 99
get_val(Val((1,2,(3,4)))) ⟹ (1,2,(3,4))
get_val(Val((:L,:D))) ⟹ (:L,:D)
```

**Ограничение.**

Параметр в `Val` должен быть "константой", т.е. представим в виде
комбинации битов известной длины.

Строка `"L"` - не годится, а символ `:L` - годится.

## Специализация функции по $n$

- Перенос `n` из данных в тип, приводит к тому, что компилятор
  производит вычисления над `n` во время компиляции!

```{julia}
#| output: false
function pw_rec_pe(::Val{n}, x::T) where {n, T}
    if iszero(n)
        one(T)
    elseif isodd(n)
        x * pw_rec_pe(Val(n - 1), x)
    else
        pw_rec_pe(Val(n ÷ 2), x * x)
    end
end
```

Проверяем

```{julia}
Tuple(pw_rec_pe(Val(n), "Abc") for n in 0:5)
```

## Вот что получается

```{julia}
@code_typed pw_rec_pe(Val(5), 10.0)
```

- Использование специализации функций по типам, встроенной в Джулию,
  часто позволяет обойтись без метапрограммирования.
- Компилятор достаточно хитёр: он умеет распространять константы,
  удалять недостижимый код и раскрывать вызовы функций.
- Компилятор не сумел удалить избыточное умножение на `1.0` поскольку
  для этого надо знать свойства `1.0` и `*` (что $x * 1.0 = x$ для
  любого $x$).
- Специалисты по вычислительным методам любят записывать алгоритмы с
  помощью циклов, а не с помощью рекурсии.

## Переход к хвостовой рекурсии

```{julia}
#| output: false
function pw_tail_rec(n, x::T) where {T}
    pw_tail_rec(n, one(T), x)
end

function pw_tail_rec(n, r, x)
    if iszero(n)
        r
    elseif isodd(n)
        pw_tail_rec(n - 1, r * x, x)
    else
        pw_tail_rec(n ÷ 2, r, x * x)
    end
end
```

Проверяем:

```{julia}
Tuple(pw_tail_rec(n, "Abc") for n = 0:5)
```

## Замена рекурсии на цикл

```{julia}
#| output: false
function pw_loop(n, x::T) where {T}
    r = one(T)
    while n > 0
        if isodd(n)
            r = r * x; n = n - 1
        else
            x = x * x; n = n ÷ 2
        end
    end
    return r
end
```

Проверяем:

```{julia}
Tuple(pw_loop(n, "Abc") for n = 0:5)
```

## Вычисления над $n$ во время компиляции

```{julia}
#| output: false
@generated function pw_gen(::Val{n}, x::T) where {n, T}
    k = n
    b = Expr[]

    push!(b, :(r = $(one(T))))

    while k > 0
        if isodd(k)
            push!(b, :(r = r * x)); k = k - 1
        else
            push!(b, :(x = x * x)); k = k ÷ 2
        end
    end

    push!(b, :(return r))

    b = quote $(b...) end
    Core.println(string(cleanup(b)))
    return b
end
```

## Какой код получается

```{julia}
pw_gen(Val(7), "Abc")
```

- Сгенерированный код напечатался из-за того, что в определение функции
  был, для отладки, вставлен вызов `Core.println`.

## Пакет `CompTime`

- Позволяет превращать обычные функции в генераторы функций.
- Генератор получается из обычной функции следующим образом.
  - Вставляем аннотацию `@ct_enable` перед определением функции.
  - Каждый параметр `v`, значение которого будет известно во время
    генерации функции, заменяем на `@ct(v)`.
  - В теле функции каждое подвыражение `e`, которое должно вычисляться
    во время генерации заменяем на `@ct(e)`.
  - Перед управляющими конструкциями (`while`, `for`, `if`), которые
    должны быть вычислены во время генерации, вставляем аннотацию
    `@ct_ctrl`.
- Реализация: <https://github.com/AlgebraicJulia/CompTime.jl>
- Размер реализации: **267 строчек**. :clap:

## Использование пакета `CompTime`

::: {.panel-tabset}

### ---

```julia
function pw_loop(n, x::T) where {T}
    k = n
    r = one(T)
    while k > 0
        if isodd(k)
            r = r * x; k = k - 1
        else
            x = x * x; k = k ÷ 2
        end
    end
    return r
end
```

### `CompTime`

```{julia}
#| output: false
@ct_enable function pw_ct(@ct(n), x::T) where {T}
    @ct(k = n)
    r = @ct(one(T))
    @ct_ctrl while k > 0
        @ct_ctrl if isodd(k)
            r = r * x; @ct(k = k - 1)
        else
            x = x * x; @ct(k = k ÷ 2)
        end
    end
    return r
end
```

:::

- Функция `pw_ct` получается из функции `pw_loop` добавлением аннотаций
  `@ct_enable`, `@ct_ctrl` и `@ct`.
- `n` - часть типа и неизменяема. Поэтому - присваивается в
  переменную `k`.

## Разные способы исполнения

Чем хорош пакет `CompTime`?

- Можно написать функцию как "обыкновенную" - и отладить её обычными
  способами.
- Затем - превратить её в генератор программ, добавив аннотации.
- После этого сохраняется возможность исполнять функцию и в качестве
  генератора и как "обычную" функцию.

Генерация (и исполнение того, что получится):

```{julia}
Tuple(pw_ct(Val{n}, "Abc") for n = 0:5)
```

Обычное исполнение (при этом аннотации игнорируются):

```{julia}
Tuple(runtime(pw_ct, n, "Abc") for n = 0:5)
```

## Результаты генерации

```{julia}
@code_typed pw_ct(Val{5}, 10)
```

- Осталось лишнее умножение на $1$.

```{julia}
@code_typed pw_ct(Val{5}, "Abc")
```

- Осталась лишняя конкатенация с `""`.


## "Сырой" результат генерации

`debug` позволяет увидеть, что получается сразу после генерации, до
того, как компилятор выполняет разные оптимизации.

```{julia}
debug(pw_ct, Val{5}, 10) |> cleanup
```

## Оптимизация вычислений с `r`

```{julia}
#| output: false
@ct_enable function pw_opt_ct(@ct(n), x::T) where {T}
    @ct_ctrl if iszero(n) return @ct(one(T)) else
        @ct(k = n); @ct(r1 = true)

        @ct_ctrl while k > 1
            @ct_ctrl if isodd(k)
                @ct_ctrl if r1
                    r = x; @ct(r1 = false)
                else
                    r = r * x
                end
                @ct(k = k - 1)
            else
                x = x * x; @ct(k = k ÷ 2)
            end
        end

        @ct_ctrl if r1 return x else return r * x end
    end
end
```

- Нет умножений на `one(T)`.
- Нет лишних присваиваний `r`.

## Результаты генерации

Для разных $n$:

```{julia}
Tuple(pw_opt_ct(Val{n}, "Abc") for n in 0:5)
```

Для чисел:

```{julia}
@code_typed pw_opt_ct(Val{5}, 10)
```

Для строк:

```{julia}
@code_typed pw_opt_ct(Val{5}, "Abc")
```

- Умножений на `one(T)` - нет.


## "Сырые" результаты генерации

::: {.panel-tabset}

### 0

$n=0$

```{julia}
debug(pw_opt_ct, Val{0}, 10) |> cleanup
```

### 1

$n=1$

```{julia}
debug(pw_opt_ct, Val{1}, 10) |> cleanup
```

### 2

$n=2$

```{julia}
debug(pw_opt_ct, Val{2}, 10) |> cleanup
```

### 3

$n=3$

```{julia}
debug(pw_opt_ct, Val{3}, 10) |> cleanup
```


### 4

$n=4$

```{julia}
debug(pw_opt_ct, Val{4}, 10) |> cleanup
```

### 5

$n=5$

```{julia}
debug(pw_opt_ct, Val{5}, 10) |> cleanup
```

### 6

$n=6$

```{julia}
debug(pw_opt_ct, Val{6}, 10) |> cleanup
```

### 7

$n=7$

```{julia}
debug(pw_opt_ct, Val{7}, 10) |> cleanup
```

:::

## Второй пример: схема Горнера

Polynomial:

$p(x) = a_1 + a_2 x + \cdots + a_n x^{n-1}$

Horner's method:

$p(x) = (((a_n x  + a_{n-1}) x + a_{n-2}) x + \cdots + a_{2})x + a_{1}$


Реализация на Джулии:

```{julia}
#| output: false
function horner(a, x)
    n = length(a)
    y = a[n]

    for k in n-1:-1:1
        y = x * y + a[k]
    end

    return y
end
```

## Схема Горнера: как задать `a`?

Коэффициенты `a` могут быть заданы как вектор (одномерный массив):

```{julia}
horner([11, 12, 13, 14], 10)
```

или как значение любого иного типа, для которого определены операции `length` и извлечение элемента по индексу `a[k]`.

Например, можно задать коэффициенты как упорядоченную n-ку (tuple):

```{julia}
t = (11, 12, 13, 14)
horner(t, 10)
```

А чем n-ка лучше, чем вектор? Тем, что она - ***неизменяемое
значение***, которое можно "упаковать" в тип!

```{julia}
Val{t}
```

А вектор - это изменяемый (mutable) объект, и для него такой "номер" -
не проходит"

## Схема Горнера: специализация по `a`

::: {.panel-tabset}

### ---

```julia
function horner(a, x)
    n = length(a)
    y = a[n]

    for k in n-1:-1:1
        y = x * y + a[k]
    end

    return y
end
```

### `CompTime`

```{julia}
#| output: false
@ct_enable function horner_ct(@ct(a), x)
    @ct(n = length(a))
    y = @ct(a[n])

    @ct_ctrl for k in n-1:-1:1
        y = x * y + @ct(a[k])
    end

    return y
end
```

###

:::

Исполняем двумя способами:

```{julia}
runtime(horner_ct, t, 10)
```

```{julia}
horner_ct(Val{t}, 10)
```

## Схема Горнера: результат генерации

```{julia}
debug(horner_ct, Val{t}, 10) |> cleanup
```

- Цикл - развёрнут.
- Коэффициенты `a` - подставлены в нужные места (выборка по индексу -
  исчезла).

## Выводы

- Возможности автоматической специализации программ (суперкомпиляции,
  частичных вычислений) - ограничены, поскольку при применении в
  конкретных ситуациях часто требуется учитывать дополнительную
  информацию, которая может быть очевидна для человека, но не для
  компьютера:
  - Какие циклы разворачивать, а какие нет?
  - Какими математическими свойствами обладают те или иные операции?
  - Какие способы решения задачи лучше выбрать в той или иной ситуации?
- Дополнительная информация может быть внесена, если писать генератор
  остаточной программы "вручную".
- Julia предоставляет средства, с помощью которых можно написать
  "обычную" программу, отладить её традиционными средствами, а затем -
  добавить аннотации, превращающие её в генератор остаточных программ.
