# Julia: стадирование с оптимизациями</br>(пример: HMM</br>= Hidden Markov model)

## Что такое</br>"стадирование программ"?

### Стадирование: одна пропасть - два прыжка

Стадированная программа выполняется **в два этапа**: @Taha2004,
@Kiselyov2018.

- На **первом** этапе, выполняется некоторая часть вычислений и
  генерируется "остаточная" программа.
- На **втором** этапе, выполняется остаточная программа и доделываются
  те вычисления, которые не удалось сделать на первом этапе.
- Вычисления, которые нужно сделать на первом этапе, помечаются
  **аннотациями**.
- **Непротиворечивость** аннотаций проверяется **автоматически**.

**Главный принцип стадирования** (который _не выполняется_, например,
для шаблонов в C++).

- Если стереть аннотации, то получается корректная программа, которую
  можно исполнить обычным способом.
- Если принять во внимание аннотации, из программы можно автоматически
  сгенерировать генератор остаточных программ.

## Пример: скрытая марковская модель

В HMM (hidden Markov model) вероятность перехода в следующее состояние
вычисляется путём умножения матрицы на вектор, где матрица содержит
вероятности переходов между состояниями.

```c
int ∗hmm(int n, int ∗∗a, int ∗v) {
  int ∗w = (int∗) calloc(n, sizeof (int)),
  for (int i = 0, i < n; i++)
    for (int j =0; j < n; j++)
      w[i] += a[i][j] ∗ v[j];
  return w;
}
```

Что требуется сделать?

- В зависимости от уровня разреженности матрицы, нужно развернуть
  некоторые циклы (полностью или частично).

- Кроме того, желательно упростить программу, используя свойства
  умножения и сложения: $0 ∗ x = 0$ и $0 + x = x$.

Переписываем эту функцию на Джулии, а затем - расставляем аннотации, чтобы получить стадированную программу.

## Умозаключения (которые будут сделаны в конце доклада)

- Стадирование - творческий процесс, поскольку (корректные) аннотации
  могут быть расставлены **разными** способами.
- В программу можно добавлять вычисления, которые **замедляют**
  программу при обычном исполнении, но **улучшают** результат
  стадирования. При этом, программу можно **тестировать и отлаживать
  традиционными средствами**.
- Julia содержит средства (generated functions), с помощью которых можно
  реализовать стадирование.
- Пример реализации стадирования - пакет `CompTime`. Но, при желании,
  можно реализовать и другие варианты стадирования.

## Ссылки

### Исходные тексты

- <https://github.com/sergei-romanenko/julia-samples/tree/main/CompTimeSamples>

### Библиография

- Aktemur, Baris, Yukiyoshi Kameyama, Oleg Kiselyov, и Chung-chieh Shan.
  2013. «Shonan challenge for generative programming: short position
  paper». В _Proceedings of the ACM SIGPLAN 2013 Workshop on Partial
  Evaluation and Program Manipulation_, 147–54. PEPM ’13. New York, NY,
  USA: Association for Computing Machinery.
  [https://doi.org/10.1145/2426890.2426917](https://doi.org/10.1145/2426890.2426917).

- Kiselyov, Oleg. 2018. «Reconciling Abstraction with High Performance:
  A MetaOCaml approach». _Found. Trends Program. Lang._ 5 (1): 1–101.
  [https://doi.org/10.1561/2500000038](https://doi.org/10.1561/2500000038).

- Taha, Walid. 2004. «A Gentle Introduction to Multi-stage Programming».
  В _Domain-Specific Program Generation: International Seminar, Dagstuhl
  Castle, Germany, March 23-28, 2003. Revised Papers_, под редакцией
  Christian Lengauer, Don Batory, Charles Consel, и Martin Odersky,
  30–50. Berlin, Heidelberg: Springer Berlin Heidelberg.
  [https://doi.org/10.1007/978-3-540-25935-0\_3](https://doi.org/10.1007/978-3-540-25935-0_3).
