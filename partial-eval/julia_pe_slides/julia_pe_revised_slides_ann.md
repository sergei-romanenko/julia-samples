# С.А.Романенко. Специализация программ в недрах экосистемы Julia

## Repetitio est mater studiorum<br/>(Повторение - мать учения!)

Доклад на объявленную тему уже делался. Однако, в результате творческих
размышлений, произошло некоторое переосмысление и/или переосознание
материала. В результате чего, возникло желание рассказать то же самое
второй раз.

В результате, к презентации кое-что добавлено, а кое-что - удалено
(чтобы не отвлекало от главного).

## Почему специализаторы программ мало популярны среди "простого народа"?

Как известно, в области специализации программ имеются достижения,
интересные с теоретической точки зрения. И даже было показано, что на
основе этой теории можно создавать специализаторы, которые работают
достаточно быстро и производят вполне разумные и полезные результаты.
Однако, когда дело дошло до внедрения этих достижений "в народное
хозяйство", то обнаружилось, что "процесс не идёт" (или, во всяком
случае, идёт чрезвычайно вяло).

Проблема, вероятно, состоит в том, что специализаторы пытались внедрять
как изделия, **существующие отдельно от компиляторов**. А это создаёт
психологические барьеры для пользователей "из простого народа".

- Во-первых, пользователь должен принимать радикальное решение:
  использовать специализацию программ или нет? А нельзя ли без неё
  обойтись в данном конкретном маленьком случае (и не делать большие
  вложения в изучение ещё одной технологии программирования)?
- Во-вторых, если попытаться использовать специализатор "в тёмную", не
  понимая как он работает, то и результаты его использования будут очень
  сомнительные...

Здесь имеется некоторая аналогия с оптимизирующими компиляторами. Вот,
представим себе, что оптимизатор программ - это изделие, которое
существует отдельно от компилятора. И нужно сначала вызывать компилятор,
а потом - оптимизатор (или наоборот). И при этом смотреть, а что там
выдаёт оптимизатор? И не нужно ли как-то тонко поуправлять
оптимизатором, чтобы он не ухудшил программу, а улучшил?

Ясно, что при такой организации дела, большинство пользователей
испугаются и не станут связываться с оптимизатором. За исключением
некоторого количества людей, которые очень любопытны (или которым очень
нужно).

Однако, как мы знаем, оптимизаторы программ широко используются на
практике. И это - благодаря тому, что разработчики не стали убеждать
пользователей в том, что оптимизация программ - это хорошее и полезное
дело, а просто поставили пользователей в безвыходное положение, заставив
их использовать оптимизаторы "из-под палки"! А именно - **встроили
оптимизаторы внутрь компиляторов**.

Таким образом, пользователь не имеет возможности выбирать: использовать
или не использовать? Это решение умные люди приняли за него. При этом
пользователь может даже и не осознавать, что он пользуется
оптимизатором, поскольку он спрятан внутри компилятора. Впрочем,
конечно, "ослиные уши" оптимизатора, всё же немного торчат наружу в виде
некоторых опций компилятора и рекомендаций по стилю написания программ
("пиши так - и программа будет работать быстрее").

## Чтобы пользователь не отказался, не надо у него спрашивать!

Отсюда возникает вопрос: а нельзя ли организовать внедрение
специализаторов "в народное хозяйство" аналогичным образом: **встроив
специализацию программ в самое нутро системы программирования**?

Разработчики системы программирования Джулия (Julia) так и поступили!
При этом, они так старательно упрятали специализатор в недра системы,
что большинство пользователей даже и не догадывается о его
существовании.

Однако, небольшое исследование (выполненное "методом научного тыка")
показывает, что этот специализатор таки существует. И может делать не
меньше, чем классические специализаторы вроде Mix/Unmix. И даже - может
делать больше. Например - умеет выполнять специализацию функций по
аргументам, которые являются функциями.

## Следим за руками: специализация по типам вместо специализации по константам!

Обман "простого народа" в Джулии основан на том, что вместо
специализации **по значениям** аргументов функции выполняется
специализация **по типам** аргументов.

Определение функции в Джулии состоит из набора правил (которые в Джулии
называются "методами"). Методы отличаются друг от друга типами
параметров, и могут записываться в любом порядке.

В момент вызова функции (в процессе **исполнения** программы)
выясняется, каковы типы аргументов и подбирается метод, у которого типы
параметров "наилучшим" образом соответствуют типам аргументов.

А именно, для типов определено отношение частичного порядка, и
выбирается такой метод, для которого типы аргументов являются подтипами
по отношению к типам соответствующих параметров. После чего генерируется
специализированная версия метода, у которой типы параметров совпадают с
типами аргументов.

> Таким образом, в то время как в "классических" специализаторах
> программ (вроде Mix и Unmix) специализация происходит по **значениям**
> параметров, в Джулии специализация происходит по **типам** параметров.

## Следим за руками: типы являются полноправными значениями!

В Джулии типы **являются** значениями, и с ними можно работать во время
исполнения программы (а не только во время компиляции).

При этом, "обычные" константы **можно превращать в типы**.

> Таким образом, "обёртывая" константы в типы, получаем возможность
> выполнять специализацию по константам (как в "классических"
> специализаторах).

## 1-я проекция Футамуры

В случае 1-й проекции Футамуры требуется выполнить специализацию
интерпретатора по отношению к программе (которая является "обычной"
константой).

> **Вопрос:** как реализовать 1-ю проекцию Футамуры средствами Джулии?
> 
> **Ответ:** изобразим программу в виде типа. Тогда интерпретатор будет
> проспециализирован по отношению к типу.

## Ссылки на материалы по теме доклада

- The Julia Programming Language <https://julialang.org/>.
- Суперкомпилятор SPSC, написанный на Julia:
  <https://github.com/sergei-romanenko/spsc/tree/master/spsc-lite-julia>.
- Стадированная многорезультатная суперкомпиляция, реализованная на
  Julia: <https://github.com/sergei-romanenko/StagedMRSC.jl>.
- Материалы расследования: <https://github.com/sergei-romanenko/julia-samples>.
- Презентация:  
  <https://disk.yandex.ru/i/WDEITmPjD85VbQ> (4:3)
  <https://disk.yandex.ru/i/A3M-vTV6i15PIQ> (16:9)

## Некоторые статьи

- Tim Besard, Valentin Churavy, Alan Edelman, Bjorn De Sutter. **Rapid
  software prototyping for heterogeneous and distributed platforms.**
  Advances in Engineering Software, Volume 132, 2019, Pages 29-46, ISSN  
  0965-9978.
  <https://doi.org/10.1016/j.advengsoft.2019.02.002>

- Martin Biel, Arda Aytekin, Mikael Johansson. **POLO.Jl: Policy-based
  optimization algorithms in Julia.** Advances in Engineering Software,
  Volume 136, 2019, 102695, ISSN 0965-9978.  
  <https://doi.org/10.1016/j.advengsoft.2019.102695>

- Tim Besard, Christophe Foket, Bjorn De Sutter. **Effective Extensible
  Programming: Unleashing Julia on GPUs.** In _IEEE Transactions on
  Parallel and Distributed Systems_, vol. 30, no. 4, pp. 827-841, 1
  April 2019.  
  <https://doi.org/10.1109/TPDS.2018.2872064>

- Benjamin Biggs, Ian McInerney, Eric C. Kerrigan, George A.
  Constantinides. **High-level Synthesis using the Julia Language.**
  Presented at the 2nd Workshop on Languages, Tools, and Techniques for
  Accelerator Design (LATTE'22), March 1, 2022.  
  <https://arxiv.org/abs/2201.11522>

- Luo, Xiu-Zhe & Jinguo, Liu & Zhang, Pan & Wang, Lei. (2020). **Yao.jl:
  Extensible, Efficient Framework for Quantum Algorithm Design.**
  Quantum. 4\. 341\. 10.22331/q-2020-10-11-341.  
  <https://quantum-journal.org/papers/q-2020-10-11-341/>
  <https://arxiv.org/abs/1912.10877>
